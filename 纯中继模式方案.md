# 穿透：纯中继模式内网穿透系统设计方案

## 一、设计目标

实现不同局域网电脑之间的端口映射穿透功能，采用**纯中继模式**：
1. 所有流量通过公网服务器转发
2. 服务端维护客户端列表和连接映射
3. 客户端注册、发现、建立连接
4. 支持 TCP、UDP、HTTP、WebSocket 协议穿透

---

## 二、系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              公网中继服务器                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        信令 + 中继                                    │   │
│  │  ┌─────────────┐         ┌─────────────────────────────────────┐   │   │
│  │  │  客户端注册表  │         │           转发映射表                  │   │   │
│  │  │  - clientId  │         │  session_id │  client_a  │ client_b │   │   │
│  │  │  - services  │         │  abc123    │  socket    │  socket  │   │   │
│  │  │             │         │  def456    │  socket    │  socket  │   │   │
│  │  └─────────────┘         └─────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │           控制通道(WebSocket)              数据通道(TCP/UDP)          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
            ▲                                    ▲
            │ WebSocket (控制消息)               │ TCP/UDP (数据转发)
            │                                    │
    ┌───────┴────────┐                  ┌───────┴────────┐
    │   客户端A       │                  │   客户端B       │
    │  (NAT后)       │  ◄────所有流量经服务器────────►  (NAT后)        │
    │                │                  │                │
    │ ┌────────────┐ │                  │ ┌────────────┐ │
    │ │本地服务    │ │                  │ │本地服务    │ │
    │ │:8080      │ │                  │ │:3000      │ │
    │ └────────────┘ │                  │ └────────────┘ │
    └────────────────┘                  └────────────────┘
```

### 2.2 协议说明

**单端口协议复用**：控制通道和数据中继共用一个端口（默认 8200），通过首字节检测区分：

| 连接类型 | 首字节特征 | 路由到 |
|---------|-----------|--------|
| WebSocket 控制通道 | HTTP 请求方法 (`GET`/`POST` 等) | HTTP 服务器 → WebSocket 升级 |
| TCP 数据中继 | 魔数 `0xFD 0x01` | 中继转发模块 |
| UDP 数据 | 无（UDP 协议独立监听同一端口） | UDP 中继模块 |

**控制通道**：
- 传输层：TCP（可靠传输）
- 应用层：WebSocket（`ws://` 协议，双向通信）
- 优势：自动处理 NAT 穿透，兼容性好

**数据中继通道**：
- TCP 中继：直接转发 TCP 字节流（支持 HTTP、WebSocket、SSE 等）
- UDP 中继：转发 UDP 数据报
- 无需额外封装，性能最优

### 2.3 连接建立流程

```
场景：用户应用（SSH/浏览器/任意应用）通过 clientA 访问 clientB 的服务

┌────────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ 用户应用    │    │ 客户端A   │    │  服务端   │    │ 客户端B   │
│ (SSH/浏览器)│    │ (本地代理) │    │  (中继)   │    │ (目标)    │
└─────┬──────┘    └────┬─────┘    └────┬─────┘    └────┬─────┘
      │                │               │               │
      │  1. REGISTER   │               │               │
      │  ◄─────────────┼───────────────►               │
      │                │               │               │
      │  2. 用户连接到 clientA:8080    │               │
      ├───────────────►│               │               │
      │                │               │               │
      │                │  3. CONNECT_REQUEST {toClientId: B, port: 8080}
      │                ├───────────────►               │
      │                │               │  4. 创建 sessionId=abc123
      │                │               │               │
      │                │  5. CREATE_SESSION {sessionId, peer: B}
      │                │◄───────────────────────────────┤
      │                │               │  6. CONNECT_REQUEST {from: A, sessionId}
      │                │               ├───────────────►│
      │                │               │               │  7. ACCEPT_SESSION
      │                │               │◄───────────────┤
      │                │               │               │
      │                │  8. 连接中继通道               │  9. 连接中继通道
      │                ├───────────────►◄───────────────┤
      │                │     (TCP)      │     (TCP)      │
      │                │               │               │
      │  10. 数据转发  │               │               │
◄─────┼───────────────┼───────────────┼───────────────┤
      │     用户↔A↔Relay↔B            │               │
      │                │               │               │
```

---

## 四、详细设计

### 3.1 服务端设计

#### 3.1.1 模块结构

```
server/
├── index.ts              # 服务端入口（协议复用路由）
├── signaling.ts          # 信令处理（WebSocket）
├── relay.ts              # 中继转发（TCP/UDP）
├── client-manager.ts     # 客户端管理
├── session-manager.ts    # 会话管理
└── config.ts             # 配置
```

#### 3.1.2 数据结构

```typescript
// 客户端信息
interface Client {
  id: string;                    // 客户端唯一ID
  registeredAt: number;          // 注册时间戳
  lastHeartbeat: number;         // 最后心跳时间
  controlSocket?: WebSocket;     // 控制通道连接
}

// 在线状态判断：clients.has(clientId) && socket.readyState === WebSocket.OPEN

// clientId 冲突处理：新连接替换旧连接
// 适用于网络切换、重启等场景

// 中继会话
// clientA 作为网关，多个外部用户通过 clientA 访问 clientB
interface RelaySession {
  id: string;                    // 会话ID（唯一标识，如 "abc123"）
  clientA: string;               // 网关客户端 ID
  clientB: string;               // 目标客户端 ID
  port: number;                  // clientB 的目标端口
  socketA?: Socket;              // clientA 数据通道（TCP）
  socketB?: Socket;              // clientB 数据通道（TCP）
}

// 存储：Map<string, RelaySession>，key = sessionId
// 场景：多个浏览器用户同时通过 clientA 访问 clientB:8080
//   用户1 → clientA → 中继 → clientB:8080 (session: abc123)
//   用户2 → clientA → 中继 → clientB:8080 (session: def456)
// UDP：单独管理 Map<sessionId, {remoteA, remoteB}>
```

#### 3.1.3 信令协议（WebSocket消息）

```typescript
// 客户端 → 服务端
type ClientToServerMessage =
  | RegisterMessage
  | GetClientListMessage
  | ConnectRequestMessage
  | AcceptSessionMessage
  | RejectSessionMessage
  | HeartbeatMessage
  | UnregisterMessage;

// 服务端 → 客户端
type ServerToClientMessage =
  | RegisterResponseMessage
  | ClientListMessage
  | ConnectRequestMessage
  | CreateSessionMessage
  | SessionClosedMessage
  | ErrorMessage;

// 消息定义
interface RegisterMessage {
  type: 'register';
  payload: {
    clientId: string;
  };
}

interface RegisterResponseMessage {
  type: 'register_response';
  payload: {
    success: boolean;
    assignedId?: string;
    existingKicked?: boolean;  // 是否踢掉了旧连接
    error?: string;
  };
}

interface GetClientListMessage {
  type: 'get_client_list';
}

interface ClientListMessage {
  type: 'client_list';
  payload: {
    clients: ClientInfo[];
  };
}

interface ClientInfo {
  id: string;
}

interface ConnectRequestMessage {
  type: 'connect_request';
  payload: {
    fromClientId: string;
    toClientId: string;
    remotePort: number;      // 目标端口（标识要连接的服务）
    localPort: number;       // 映射到本地端口
    sessionId: string;
  };
}

interface CreateSessionMessage {
  type: 'create_session';
  payload: {
    sessionId: string;
    peerClientId: string;
    service: Service;
    relayAddr: {
      host: string;
      port: number;
      protocol: 'tcp' | 'udp';
    };
  };
}

interface AcceptSessionMessage {
  type: 'accept_session';
  payload: {
    sessionId: string;
  };
}

interface RejectSessionMessage {
  type: 'reject_session';
  payload: {
    sessionId: string;
    reason?: string;
  };
}

interface HeartbeatMessage {
  type: 'heartbeat';
  payload: {
    timestamp: number;
  };
}
```

#### 3.1.4 中继服务器

```typescript
class RelayServer {
  private sessions = new Map<string, RelaySession>();

  // TCP中继
  handleTCPConnection(socket: Socket, sessionId: string, clientId: string) {
    let session = this.sessions.get(sessionId);

    if (!session) {
      // 创建新会话
      session = {
        id: sessionId,
        clientA: clientId,
        clientB: null,
        socketA: socket,
        socketB: null,
        status: 'connecting',
        createdAt: Date.now(),
        bytesTransferred: 0
      };
      this.sessions.set(sessionId, session);
    } else {
      // 会话已存在，添加第二个客户端
      if (!session.clientB) {
        session.clientB = clientId;
        session.socketB = socket;
        session.status = 'connected';
        this.startForwarding(session);
      }
    }

    // 处理断开
    socket.on('close', () => {
      this.handleSessionClose(sessionId);
    });
  }

  // 开始双向转发
  private startForwarding(session: RelaySession) {
    const { socketA, socketB } = session;

    // A → B
    socketA?.on('data', (data) => {
      socketB?.write(data);
      session.bytesTransferred += data.length;
    });

    // B → A
    socketB?.on('data', (data) => {
      socketA?.write(data);
      session.bytesTransferred += data.length;
    });

    // 错误处理
    socketA?.on('error', (err) => this.handleError(session, err));
    socketB?.on('error', (err) => this.handleError(session, err));
  }

  // UDP中继
  private udpSockets = new Map<string, dgram.Socket>();

  handleUDPPacket(data: Buffer, rinfo: dgram.RemoteInfo, sessionId: string) {
    const session = this.sessions.get(sessionId);
    if (!session || session.status !== 'connected') return;

    // 转发给对方
    const targetSocket = this.getPeerUDPSocket(sessionId, rinfo);
    targetSocket?.send(data, session.peerPort, session.peerHost);
  }
}
```

### 3.2 客户端设计

#### 3.2.1 模块结构

```
client/
├── index.ts              # 客户端入口
├── signaling-client.ts   # 信令客户端
├── relay-client.ts       # 中继客户端
├── service-proxy.ts      # 服务代理（本地端口监听）
├── connection.ts         # 连接管理
└── config.ts             # 配置
```

#### 3.2.2 核心流程

```typescript
class Client {
  private signaling: SignalingClient;
  private relayClient: RelayClient;
  private services = new Map<string, ServiceProxy>();

  async start(config: ClientConfig) {
    // 1. 连接信令服务器
    await this.signaling.connect(config.serverUrl);

    // 2. 注册客户端
    await this.signaling.register({
      clientId: config.clientId,
      services: config.services
    });

    // 3. 启动心跳
    this.startHeartbeat();

    // 4. 监听连接请求
    this.signaling.on('connect_request', async (req) => {
      await this.handleIncomingConnection(req);
    });
  }

  // 发起连接（连接到其他客户端的服务）
  async connectTo(targetClientId: string, serviceId: string) {
    // 1. 请求连接
    const response = await this.signaling.requestConnect({
      toClientId: targetClientId,
      serviceId: serviceId
    });

    // 2. 收到会话创建通知
    const session = response.session;

    // 3. 连接中继服务器
    const relaySocket = await this.relayClient.connect(session.relayAddr);

    // 4. 创建本地代理
    const proxy = new ServiceProxy({
      localPort: session.localPort,
      relaySocket: relaySocket
    });

    await proxy.start();

    return proxy;
  }

  // 处理入站连接
  async handleIncomingConnection(request: ConnectRequest) {
    const { sessionId, peerClientId, service, relayAddr } = request;

    // 1. 查找请求的服务
    const targetService = this.findService(service.id);

    // 2. 连接本地服务
    const localSocket = await this.connectToLocalService(targetService);

    // 3. 连接中继服务器
    const relaySocket = await this.relayClient.connect(relayAddr);

    // 4. 接受会话
    await this.signaling.acceptSession({ sessionId });

    // 5. 开始转发
    this.startForwarding(localSocket, relaySocket);

    // 6. 通知对端连接已建立
    await this.signaling.notifyConnected({ sessionId });
  }
}
```

#### 3.2.3 服务代理（本地端口监听）

```typescript
class ServiceProxy {
  private server?: net.Server;
  private connections = new Set<net.Socket>();

  async start(config: ProxyConfig): Promise<void> {
    // 端口冲突检测
    const isPortAvailable = await this.checkPortAvailable(config.localPort);
    if (!isPortAvailable) {
      throw new Error(
        `端口 ${config.localPort} 已被占用。请选择其他端口，或使用 --local-port 指定不同端口。`
      );
    }

    this.server = net.createServer((socket) => {
      this.handleClientConnection(socket);
    });

    this.server.listen(config.localPort, config.localHost);
  }

  // 检测端口是否可用
  private async checkPortAvailable(port: number): Promise<boolean> {
    return new Promise((resolve) => {
      const tester = net.createServer()
        .once('error', () => resolve(false))
        .once('listening', () => {
          tester.close();
          resolve(true);
        })
        .listen(port);
    });
  }

  private handleClientConnection(clientSocket: net.Socket) {
    // 连接到中继服务器
    const relaySocket = net.connect(this.relayAddr);

    // 双向转发
    clientSocket.on('data', (data) => {
      relaySocket.write(data);
    });

    relaySocket.on('data', (data) => {
      clientSocket.write(data);
    });

    // 清理
    clientSocket.on('close', () => {
      relaySocket.destroy();
      this.connections.delete(clientSocket);
    });

    relaySocket.on('close', () => {
      clientSocket.destroy();
    });

    this.connections.add(clientSocket);
  }
}
```

### 3.3 协议支持

#### 3.3.1 协议映射表

| 应用层协议 | 底层传输 | 中继方式 | 说明 |
|-----------|---------|---------|------|
| TCP | TCP | TCP中继 | 原样转发TCP流 |
| UDP | UDP | UDP中继 | 转发UDP数据报 |
| HTTP | TCP | TCP中继 | HTTP是TCP之上的应用，无需特殊处理 |
| WebSocket | TCP | TCP中继 | WS基于TCP，无需特殊处理 |

#### 3.3.2 中继数据通道

```typescript
// TCP中继：直接转发字节流
// 无需封装，直接使用原生TCP socket

// UDP中继：需要会话标识
interface UDPRelayPacket {
  sessionId: string;  // 4 bytes
  length: number;     // 2 bytes
  data: Buffer;       // variable
}

// UDP打洞不需要，纯中继直接转发
// 服务端根据 (remoteIP, remotePort) 识别会话
```

---

## 五、配置

### 4.1 服务端配置

```typescript
interface ServerConfig {
  // 服务器监听地址（单端口复用：控制 + 数据中继）
  host: string;
  port: number;                  // 服务端口（默认 8200）

  // 心跳配置
  heartbeatTimeout: number;      // 心跳超时，超时则判定客户端掉线（默认 60s）
}
```

### 4.2 客户端配置

```typescript
interface ClientConfig {
  // 服务器连接（WebSocket 控制通道）
  serverUrl: string;           // 默认: ws://net.feng3d.com:8200

  // 客户端标识
  clientId?: string;           // 可选，不指定则自动生成
}
```

---

## 六、实现计划

### 5.1 模块划分

| 模块 | 文件 | 代码量 | 优先级 |
|-----|------|-------|-------|
| 共享-协议定义 | `shared/protocol.ts` | ~150行 | P0 |
| 服务端-信令 | `server/signaling.ts` | ~200行 | P0 |
| 服务端-客户端管理 | `server/client-manager.ts` | ~100行 | P0 |
| 服务端-会话管理 | `server/session-manager.ts` | ~150行 | P0 |
| 服务端-中继 | `server/relay.ts` | ~200行 | P0 |
| 服务端-管理页面 | `server/admin-server.ts` | ~200行 | P1 |
| 服务端-CLI | `server/cli.ts` | ~150行 | P0 |
| 客户端-信令 | `client/signaling-client.ts` | ~150行 | P0 |
| 客户端-中继 | `client/relay-client.ts` | ~100行 | P0 |
| 客户端-服务代理 | `client/service-proxy.ts` | ~200行 | P0 |
| 客户端-管理页面 | `client/admin-server.ts` | ~200行 | P1 |
| 客户端-CLI | `client/cli.ts` | ~150行 | P0 |
| 客户端-守护进程 | `client/daemon.ts` | ~100行 | P1 |

**总计：约 2150 行代码**

### 5.2 开发顺序

**Phase 1: 基础框架 + 协议 (2天)**
- [ ] 共享协议定义 (`shared/protocol.ts`)
- [ ] 服务端基础框架 (`server/index.ts`)
- [ ] 客户端基础框架 (`client/index.ts`)

**Phase 2: 信令与注册系统 (2天)**
- [ ] WebSocket 信令服务器 (`server/signaling.ts`)
- [ ] 客户端管理器 (`server/client-manager.ts`)
- [ ] 客户端注册/发现 (`client/signaling-client.ts`)
- [ ] 心跳保活机制

**Phase 3: 中继系统 (2天)**
- [ ] TCP 中继服务器 (`server/relay.ts`)
- [ ] UDP 中继服务器 (`server/relay.ts`)
- [ ] 会话管理 (`server/session-manager.ts`)
- [ ] 客户端中继连接 (`client/relay-client.ts`)

**Phase 4: 客户端代理 (2天)**
- [ ] 本地服务代理 (`client/service-proxy.ts`)
- [ ] 连接管理 (`client/connection.ts`)
- [ ] 数据转发逻辑

**Phase 5: CLI 工具 (1天)**
- [ ] 服务端 CLI (`server/cli.ts`) - `cts`
- [ ] 客户端 CLI (`client/cli.ts`) - `ctc`
- [ ] 守护进程管理 (`client/daemon.ts`)

**Phase 6: 管理页面 (1天)**
- [ ] 服务端管理界面 (`server/admin-server.ts`)
- [ ] 客户端管理界面 (`client/admin-server.ts`)
- [ ] API 接口

**预计完成时间：10天**

---

## 七、使用示例

### 7.1 启动服务端

```bash
# 方式1: 使用 npx（推荐）
npx @feng3d/cts

# 方式2: 作为库使用
import { Server } from '@feng3d/cts';

const server = new Server({ port: 8200 });
await server.start();
```

### 7.2 启动客户端

```bash
# 使用 npx（推荐）
npx @feng3d/ctc

# 作为库使用
import { Client } from '@feng3d/ctc';

const client = new Client({
  serverUrl: 'ws://net.feng3d.com:8200'
});
await client.start();
```

### 7.3 使用场景

```
┌────────────────┐         ┌────────────────┐         ┌────────────────┐
│  电脑 A (家里)   │         │  公网服务器      │         │  电脑 B (公司)   │
│                │         │  :8200         │         │                │
│  本地服务 :8080 │◄────────►│  中继转发        │◄────────►│  访问 localhost │
│  (Web/DB等)    │  通过   │                │  通过   │  :3000 → :8080  │
└────────────────┘  中继   └────────────────┘  中继   └────────────────┘
     npx @feng3d/ctc                    npx @feng3d/cts              npx @feng3d/ctc
```

---

## 八、优缺点分析

### 7.1 优点

| 优点 | 说明 |
|-----|------|
| 实现简单 | 无需处理NAT类型、打洞时序等复杂逻辑 |
| 稳定性高 | 100%连接成功率，不受NAT类型影响 |
| 开发快速 | 预计10天完成，对比P2P方案需3-4周 |
| 易于调试 | 所有流量经过服务器，便于抓包调试 |
| 支持所有协议 | TCP/UDP/HTTP/WS 都可以直接转发 |

### 7.2 缺点

| 缺点 | 说明 | 解决方案 |
|-----|------|---------|
| 服务器带宽成本 | 所有流量经过服务器 | 按需扩容，使用CDN |
| 延迟增加 | 数据多一跳 | 选择低延迟服务器 |
| 单点故障 | 服务器挂了全挂 | 部署多台服务器，负载均衡 |
| 隐私问题 | 服务器可见所有数据 | 后期可添加端到端加密 |

### 7.3 带宽估算

```
场景：10个用户，每个用户1MB/s吞吐

中继模式带宽 = 10用户 × 1MB/s × 2(双向) = 20MB/s
           = 160Mbps

云服务器成本估算（以阿里云为例）：
- 160Mbps 带宽约 1000-2000元/月
- 100个用户 × 1MB/s = 1.6Gbps ≈ 10000元/月

建议：
- 小规模使用（<10用户）：云服务器即可
- 中等规模（10-100用户）：考虑按量计费带宽
- 大规模（>100用户）：考虑P2P混合模式
```

---

## 九、命令行工具设计

### 8.1 服务端 CLI (cts)

```bash
# 启动服务器（后台运行，崩溃自动重启，开机自启，默认端口8200）
npx @feng3d/cts

# 指定端口
npx @feng3d/cts --port 9000

# 停止服务（并移除开机自启）
npx @feng3d/cts stop
```

### 8.2 客户端 CLI (ctc)

```bash
# 启动客户端（后台运行，崩溃自动重启，开机自启，默认服务器 ws://net.feng3d.com:8200）
# 同时启动 HTTP 管理页面（默认端口 8201），并显示访问地址
npx @feng3d/ctc

# 指定服务器地址
npx @feng3d/ctc --server ws://server-ip:8200

# 指定管理页面端口
npx @feng3d/ctc --port 9000

# 停止客户端（并移除开机自启）
npx @feng3d/ctc stop
```

### 9.3 包结构

```
chuantou/
├── packages/
│   ├── shared/              # 共享模块
│   │   └── package.json     # @feng3d/chuantou-shared
│   ├── server/              # 服务端
│   │   ├── src/
│   │   ├── package.json     # @feng3d/cts (带 bin)
│   │   └── dist/cli.js      # CLI 入口
│   └── client/              # 客户端
│       ├── src/
│       ├── package.json     # @feng3d/ctc (带 bin)
│       └── dist/cli.js      # CLI 入口
```

### 9.4 package.json 配置

```json
// packages/server/package.json
{
  "name": "@feng3d/cts",
  "version": "0.1.0",
  "type": "module",
  "bin": {
    "cts": "./dist/cli.js"
  },
  "exports": {
    ".": "./dist/index.js",
    "./types": "./dist/types.d.ts"
  }
}

// packages/client/package.json
{
  "name": "@feng3d/ctc",
  "version": "0.1.0",
  "type": "module",
  "bin": {
    "ctc": "./dist/cli.js"
  },
  "exports": {
    ".": "./dist/index.js",
    "./types": "./dist/types.d.ts"
  }
}
```

## 十、Web 管理界面

### 9.1 服务端管理页面

访问地址: `http://server-ip:8200`

功能:
- 在线客户端列表
- 活跃会话监控
- 流量统计
- 系统状态

### 9.2 客户端管理页面

启动客户端时自动开启，默认访问地址: `http://localhost:8201`

功能:
- 当前注册的服务列表
- 活跃连接管理
- 连接到其他客户端
- 流量监控

```bash
# 启动时自动开启管理页面（默认端口 8201）
npx @feng3d/ctc
# 输出: 管理页面: http://localhost:8201

# 指定端口
npx @feng3d/ctc --port 9000
# 输出: 管理页面: http://localhost:8200
```

---

## 十一、集成测试

### 11.1 双向互访测试

**测试场景**：两个客户端同时作为"发起方"和"目标方"

```
┌─────────────────────────────────────────────────────────────────┐
│                        双向互访拓扑                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   用户1 → clientA:8000 ────中继────→ clientB:3000               │
│                                                                 │
│   用户2 → clientB:8000 ────中继────→ clientA:3000               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. 启动服务端
const server = new Server({ port: 8200 });
await server.start();

// 2. 启动两个客户端
const clientA = new Client({ serverUrl: 'ws://localhost:8200', clientId: 'A' });
const clientB = new Client({ serverUrl: 'ws://localhost:8200', clientId: 'B' });
await Promise.all([clientA.start(), clientB.start()]);

// 3. clientA 监听本地 3000 端口（模拟服务）
await clientA.listen(3000, (conn) => {
  conn.write('Hello from clientA:3000');
});

// 4. clientB 监听本地 3000 端口（模拟服务）
await clientB.listen(3000, (conn) => {
  conn.write('Hello from clientB:3000');
});

// 5. 用户1 连接 clientA:8000，配置转发到 clientB:3000
const proxy1 = await clientA.createProxy({
  localPort: 8000,
  targetClientId: 'B',
  targetPort: 3000
});

// 6. 用户2 连接 clientB:8000，配置转发到 clientA:3000
const proxy2 = await clientB.createProxy({
  localPort: 8000,
  targetClientId: 'A',
  targetPort: 3000
});

// 7. 验证双向连接
const conn1 = net.connect(8000);  // 用户1 连接
const conn2 = net.connect(8000);  // 用户2 连接

await Promise.all([
  new Promise(resolve => conn1.once('data', data => {
    assert(data.toString() === 'Hello from clientB:3000');
    resolve();
  })),
  new Promise(resolve => conn2.once('data', data => {
    assert(data.toString() === 'Hello from clientA:3000');
    resolve();
  }))
]);

// 8. 清理
await Promise.all([proxy1.close(), proxy2.close()]);
await Promise.all([clientA.stop(), clientB.stop()]);
await server.stop();
```

**验证点**：
- ✅ 两个客户端同时作为发起方和目标方
- ✅ 不同 sessionId 不会冲突
- ✅ 数据可以双向独立传输
- ✅ 连接关闭互不影响

### 11.2 多协议并发测试

**测试场景**：同一用户同时通过不同协议访问 clientB 的多个服务

```
┌─────────────────────────────────────────────────────────────────┐
│                      多协议并发拓扑                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   clientB 服务:                                                  │
│   - :3001 WebSocket 服务                                         │
│   - :3002 HTTP 服务                                              │
│   - :3003 TCP 服务                                               │
│   - :3004 UDP 服务                                               │
│                                                                 │
│   用户1 同时连接:                                                │
│   - clientA:8001 (WS)  ────中继────→ clientB:3001               │
│   - clientA:8002 (HTTP) ────中继────→ clientB:3002               │
│   - clientA:8003 (TCP)  ────中继────→ clientB:3003               │
│   - clientA:8004 (UDP)  ────中继────→ clientB:3004               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientB 启动多个服务
const wsServer = new WebSocketServer({ port: 3001 });
const httpServer = http.createServer().listen(3002);
const tcpServer = net.createServer().listen(3003);
const udpSocket = dgram.createSocket('udp4').bind(3004);

// 2. clientA 创建多个代理映射（同时建立 4 个会话）
const proxies = await Promise.all([
  clientA.createProxy({ localPort: 8001, targetClientId: 'B', targetPort: 3001 }),  // WS
  clientA.createProxy({ localPort: 8002, targetClientId: 'B', targetPort: 3002 }),  // HTTP
  clientA.createProxy({ localPort: 8003, targetClientId: 'B', targetPort: 3003 }),  // TCP
  clientA.createProxy({ localPort: 8004, targetClientId: 'B', targetPort: 3004 }),  // UDP
]);

// 3. 用户1 同时发起 4 个连接
const wsClient = new WebSocket('ws://localhost:8001');
const httpResponse = await fetch('http://localhost:8002');
const tcpClient = net.connect(8003);
const udpClient = dgram.createSocket('udp4');

// 4. 验证所有连接都正常工作
await Promise.all([
  new Promise(resolve => wsClient.once('open', resolve)),
  new Promise(resolve => tcpClient.once('connect', resolve)),
]);

// 5. 清理
await Promise.all(proxies.map(p => p.close()));
```

**验证点**：
- ✅ 同一用户可以同时建立多个会话
- ✅ 不同协议（WS/HTTP/TCP/UDP）独立传输
- ✅ 不同目标端口有独立的 sessionId
- ✅ 会话之间互不干扰

### 11.3 同端口 HTTP + WebSocket 混合测试

**测试场景**：clientB 的 :80 端口同时提供 HTTP 和 WebSocket 服务

```
┌─────────────────────────────────────────────────────────────────┐
│                   HTTP + WS 混合服务拓扑                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   clientB:80 同时支持:                                           │
│   - HTTP 请求 (GET /api)                                         │
│   - WebSocket (ws://host/ws)                                    │
│                                                                 │
│   clientA 只需创建一个代理映射:                                   │
│   - localPort:8080 → targetPort:80                              │
│                                                                 │
│   用户同时访问:                                                   │
│   - fetch('http://localhost:8080/api')  ────→ HTTP             │
│   - new WebSocket('ws://localhost:8080/ws') → WS               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientB 启动一个同时支持 HTTP 和 WS 的服务器
const server = http.createServer((req, res) => {
  if (req.url === '/api') {
    res.writeHead(200);
    res.end('HTTP Response');
  }
});

const wsServer = new WebSocketServer({ server, path: '/ws' });
wsServer.on('connection', (ws) => {
  ws.send('WebSocket Connected');
});

server.listen(80);  // HTTP 和 WS 共用 :80 端口

// 2. clientA 只需创建一个代理映射
const proxy = await clientA.createProxy({
  localPort: 8080,
  targetClientId: 'B',
  targetPort: 80
});

// 3. 用户同时发起 HTTP 请求和 WebSocket 连接（同一个本地端口）
const [httpResponse, wsClient] = await Promise.all([
  fetch('http://localhost:8080/api'),
  new Promise((resolve) => {
    const ws = new WebSocket('ws://localhost:8080/ws');
    ws.onopen = () => resolve(ws);
  })
]);

// 4. 验证
assert(await httpResponse.text() === 'HTTP Response');
assert(await new Promise(resolve => wsClient.onmessage = (msg) => resolve(msg.data)) === 'WebSocket Connected');

// 5. 清理
wsClient.close();
await proxy.close();
```

**原理说明**：
- 中继服务器**透明转发 TCP 字节流**，不解析应用层协议
- WebSocket 通过 HTTP Upgrade 握手建立连接
- clientB 的服务器根据 HTTP 头判断是普通请求还是 WS 升级
- **无需特殊处理**，同一个代理映射即可支持 HTTP 和 WS

**验证点**：
- ✅ 同一端口支持 HTTP 和 WebSocket
- ✅ 中继完全透明，不关心应用层协议
- ✅ HTTP 和 WS 连接可以同时存在

### 11.4 SSH 远程连接测试

**测试场景**：用户通过 SSH 客户端连接远程内网机器

```
┌─────────────────────────────────────────────────────────────────┐
│                        SSH 远程连接拓扑                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：用户在公司电脑上 SSH 到家里的开发机                      │
│                                                                 │
│   家里电脑 (clientB):                                            │
│   - SSH 服务监听 :22                                             │
│                                                                 │
│   公司电脑 (clientA):                                            │
│   - 本地监听 :2222                                               │
│   - 转发到 clientB:22                                            │
│                                                                 │
│   用户操作:                                                       │
│   $ ssh -p 2222 localhost                                       │
│   (实际上连接到家里电脑的 SSH 服务)                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientB 所在机器启动 SSH 服务器（或模拟）
// 实际环境中 SSH 服务已在 :22 运行
// 测试环境可以用 net.Server 模拟 SSH 协议
const sshServer = net.createServer((socket) => {
  // 模拟 SSH 协议握手
  socket.write('SSH-2.0-OpenSSH_9.0\r\n');

  socket.on('data', (data) => {
    // 模拟 SSH 认证响应
    if (data.toString().includes('SSH')) {
      socket.write('Protocol match accepted\r\n');
    }
  });
});
sshServer.listen(22);

// 2. clientA 创建代理映射
const proxy = await clientA.createProxy({
  localPort: 2222,
  targetClientId: 'B',
  targetPort: 22
});

// 3. 用户通过 SSH 客户端连接
// 命令行: ssh -p 2222 localhost
// 或用代码模拟 SSH 连接
const sshClient = net.connect({ port: 2222, host: 'localhost' });

sshClient.once('data', (data) => {
  // 收到 SSH 服务器响应
  assert(data.toString().includes('SSH-2.0'));
  console.log('SSH 连接成功！');

  // 4. 模拟 SSH 握手
  sshClient.write('SSH-2.0-Client\r\n');
});

// 5. 清理
sshClient.on('close', () => {
  sshServer.close();
  proxy.close();
});
```

**实际使用命令**：

```bash
# 启动客户端后，用户直接用 SSH 命令连接
ssh -p 2222 localhost

# 或配置 ~/.ssh/config 简化连接
Host home-dev
    HostName localhost
    Port 2222

# 然后: ssh home-dev
```

**验证点**：
- ✅ SSH 协议通过 TCP 透明转发
- ✅ 支持长连接（SSH 会话可持续）
- ✅ 支持交互式终端（实时双向数据流）
- ✅ 支持 SCP/SFTP（基于 SSH 的文件传输）

**注意事项**：
- SSH 对延迟敏感，建议选择低延迟的中继服务器
- SSH 会话可能长时间保持，需要心跳保活
- SSH 密钥认证完全透明，中继不干预

### 11.5 数据库远程连接测试

**测试场景**：开发人员远程连接内网数据库

```
┌─────────────────────────────────────────────────────────────────┐
│                      数据库远程连接拓扑                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：开发人员在外地连接公司内网的数据库                        │
│                                                                 │
│   公司服务器 (clientB):                                          │
│   - MySQL :3306                                                 │
│   - PostgreSQL :5432                                            │
│   - Redis :6379                                                 │
│   - MongoDB :27017                                              │
│                                                                 │
│   开发电脑 (clientA):                                            │
│   - :3306 → clientB:3306 (MySQL)                                │
│   - :5432 → clientB:5432 (PostgreSQL)                           │
│                                                                 │
│   用户操作:                                                       │
│   $ mysql -h 127.0.0.1 -P 3306 -u root                          │
│   $ psql -h 127.0.0.1 -p 5432                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientA 创建多个数据库代理映射
const proxies = await Promise.all([
  clientA.createProxy({ localPort: 3306, targetClientId: 'B', targetPort: 3306 }),  // MySQL
  clientA.createProxy({ localPort: 5432, targetClientId: 'B', targetPort: 5432 }),  // PostgreSQL
]);

// 2. 用户使用数据库客户端连接
// MySQL 连接
const mysqlConn = await mysql.createConnection({
  host: 'localhost',
  port: 3306,
  user: 'root',
});

// PostgreSQL 连接
const pgConn = new Client({
  host: 'localhost',
  port: 5432,
});
await pgConn.connect();

// 3. 验证
const [rows] = await mysqlConn.execute('SELECT 1 as result');
assert(rows[0].result === 1);

// 4. 清理
await mysqlConn.end();
await pgConn.end();
await Promise.all(proxies.map(p => p.close()));
```

**验证点**：
- ✅ 支持各类数据库协议（MySQL、PostgreSQL、Redis、MongoDB 等）
- ✅ 支持数据库连接池（多个连接共享同一代理映射）
- ✅ 支持长连接和心跳保活
- ✅ 支持大字段和二进制数据传输

### 11.6 VNC 远程桌面测试

**测试场景**：远程访问内网电脑的桌面

```
┌─────────────────────────────────────────────────────────────────┐
│                       VNC 远程桌面拓扑                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：在家远程控制公司的办公电脑                               │
│                                                                 │
│   公司电脑 (clientB):                                            │
│   - VNC 服务 :5900                                              │
│   - RDP 服务 :3389                                              │
│                                                                 │
│   家里电脑 (clientA):                                            │
│   - :5900 → clientB:5900 (VNC)                                  │
│                                                                 │
│   用户操作:                                                       │
│   $ vncviewer localhost:5900                                    │
│   或使用 VNC Viewer GUI 连接 localhost:5900                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientA 创建 VNC 代理映射
const proxy = await clientA.createProxy({
  localPort: 5900,
  targetClientId: 'B',
  targetPort: 5900
});

// 2. 用户使用 VNC Viewer 连接 localhost:5900
// VNC 是基于 RFB 协议，通过 TCP 传输
// 中继完全透明转发

// 3. VNC 连接建立后会持续传输桌面图像数据
// 需要保证稳定的长连接

// 4. 清理
await proxy.close();
```

**验证点**：
- ✅ 支持图形数据流（VNC 图像更新）
- ✅ 支持鼠标键盘输入（远程控制）
- ✅ 低延迟要求（保证操作响应速度）
- ✅ 稳定性要求（长时间会话不中断）

**注意事项**：
- VNC 传输量较大，建议高带宽中继服务器
- 可考虑压缩或低色深模式减少带宽
- RDP 协议同理，端口 :3389

### 11.7 API 开发调试测试

**测试场景**：前端开发调试调用后端 API

```
┌─────────────────────────────────────────────────────────────────┐
│                       API 开发调试拓扑                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：前端在本地开发，调用部署在内网的后端 API                   │
│                                                                 │
│   内网服务器 (clientB):                                          │
│   - REST API :8080                                              │
│   - GraphQL :4000                                               │
│   - WebSocket :3000 (实时推送)                                  │
│                                                                 │
│   开发电脑 (clientA):                                            │
│   前端服务 :5173 (Vite 开发服务器)                               │
│   代理: /api → clientB:8080                                     │
│                                                                 │
│   用户操作:                                                       │
│   浏览器访问 http://localhost:5173                              │
│   前端调用 /api/users 实际访问 clientB:8080/api/users           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientA 创建后端 API 代理
await clientA.createProxy({
  localPort: 8080,
  targetClientId: 'B',
  targetPort: 8080
});

// 2. 前端配置 Vite 代理
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
      }
    }
  }
});

// 3. 前端代码调用 API
const response = await fetch('/api/users');
const users = await response.json();

// 4. WebSocket 实时推送同时工作
const ws = new WebSocket('ws://localhost:3000/ws');
ws.onmessage = (event) => {
  console.log('实时更新:', event.data);
};

// 5. 验证
assert(Array.isArray(users));
```

**验证点**：
- ✅ 支持 CORS（跨域请求）
- ✅ 支持 WebSocket 实时通信
- ✅ 支持热重载（开发时频繁重连）
- ✅ 支持并发请求（多个 API 调用）

### 11.9 端口冲突处理测试

**测试场景**：clientA 自身有本地服务占用端口时的处理

```
┌─────────────────────────────────────────────────────────────────┐
│                       端口冲突场景拓扑                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   clientA 自身服务:                                              │
│   - HTTP 服务 :8080 (本地运行)                                  │
│                                                                 │
│   用户想要: 通过 clientA 访问 clientB:8080                       │
│                                                                 │
│   错误尝试:                                                       │
│   - createProxy({ localPort: 8080, targetClientId: 'B', targetPort: 8080 })  ❌
│     → EADDRINUSE 错误                                           │
│                                                                 │
│   正确做法:                                                       │
│   - createProxy({ localPort: 9090, targetClientId: 'B', targetPort: 8080 })  ✅
│     → 用户访问 http://localhost:9090 → clientB:8080              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientA 先启动本地 HTTP 服务占用 8080
const localServer = http.createServer((req, res) => {
  res.end('This is clientA local service');
});
localServer.listen(8080);

// 2. 尝试创建 8080 端口的代理（应该失败）
try {
  await clientA.createProxy({
    localPort: 8080,  // 与本地服务冲突
    targetClientId: 'B',
    targetPort: 8080
  });
  assert.fail('应该抛出端口冲突错误');
} catch (error) {
  assert(error.message.includes('端口') || error.message.includes('EADDRINUSE'));
  console.log('端口冲突检测正常');
}

// 3. 使用不同端口创建代理（成功）
const proxy = await clientA.createProxy({
  localPort: 9090,  // 使用未被占用的端口
  targetClientId: 'B',
  targetPort: 8080
});

// 4. 验证
// 访问 localhost:8080 → clientA 本地服务
// 访问 localhost:9090 → clientB:8080 服务

const [localResp, proxyResp] = await Promise.all([
  fetch('http://localhost:8080'),
  fetch('http://localhost:9090'),
]);

assert(await localResp.text() === 'This is clientA local service');
assert(await proxyResp.text() === 'This is clientB service');

// 5. 清理
await proxy.close();
localServer.close();
```

**设计原则**：
- ✅ 代理端口不能与 clientA 自身服务冲突
- ✅ 创建代理前先检测端口可用性
- ✅ 冲突时返回清晰的错误提示
- ✅ 用户可以选择其他端口
- ✅ 不同目标服务必须使用不同的 localPort

**CLI 使用示例**：

```bash
# 错误：8080 已被本地服务占用
$ ctc proxy create --local-port 8080 --target-client B --target-port 8080
错误: 端口 8080 已被占用。请使用 --local-port 指定其他端口。

# 正确：使用 9090 端口
$ ctc proxy create --local-port 9090 --target-client B --target-port 8080
✅ 代理创建成功: localhost:9090 → clientB:8080
访问地址: http://localhost:9090
```

### 11.10 微服务间通信测试

**测试场景**：本地开发环境连接远程微服务集群

```
┌─────────────────────────────────────────────────────────────────┐
│                      微服务通信拓扑                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   场景：本地服务需要调用远程的多个微服务                          │
│                                                                 │
│   远程集群 (clientB):                                            │
│   - 用户服务 :8001                                              │
│   - 订单服务 :8002                                              │
│   - 支付服务 :8003                                              │
│   - 消息队列 :5672 (AMQP)                                       │
│                                                                 │
│   本地开发 (clientA):                                            │
│   本地服务 :3000                                                │
│   - :8001 → clientB:8001                                        │
│   - :8002 → clientB:8002                                        │
│   - :8003 → clientB:8003                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**测试步骤**：

```typescript
// 1. clientA 批量创建微服务代理
const servicePorts = [8001, 8002, 8003];
const proxies = await Promise.all(
  servicePorts.map(port =>
    clientA.createProxy({
      localPort: port,
      targetClientId: 'B',
      targetPort: port
    })
  )
);

// 2. 本地服务调用各微服务
const userService = axios.create({ baseURL: 'http://localhost:8001' });
const orderService = axios.create({ baseURL: 'http://localhost:8002' });
const paymentService = axios.create({ baseURL: 'http://localhost:8003' });

// 3. 模拟业务流程
const user = await userService.get('/users/1');
const order = await orderService.post('/orders', { userId: user.id });
await paymentService.post('/pay', { orderId: order.id });

// 4. 验证
assert(order.data.userId === user.id);

// 5. 清理
await Promise.all(proxies.map(p => p.close()));
```

**验证点**：
- ✅ 支持多个微服务同时代理
- ✅ 支持服务间调用链路（A → B → C）
- ✅ 支持分布式追踪（透传 Trace ID）
- ✅ 支持服务发现动态更新

---

## 十二、未来扩展

### 11.1 从中继到P2P的迁移路径

```
第一阶段：纯中继（当前方案）
   └─ 快速上线，验证需求

第二阶段：添加NAT检测
   └─ 检测客户端NAT类型，收集数据

第三阶段：选择性P2P
   └─ 对简单NAT尝试P2P，失败回退中继

第四阶段：智能路由
   └─ 根据NAT类型、网络状况自动选择最优路径
```

### 11.2 可选增强功能

- [ ] 端到端加密（使用TLS）
- [ ] 客户端认证（Token）
- [ ] 数据压缩
- [ ] 多服务器负载均衡
- [ ] Web管理界面
- [ ] 流量统计和限速
- [ ] 断点续传（文件传输场景）
