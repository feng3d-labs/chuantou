# 穿透：纯中继模式内网穿透系统设计方案

## 一、设计目标

实现不同局域网电脑之间的端口映射穿透功能，采用**纯中继模式**：
1. 所有流量通过公网服务器转发
2. 服务端维护客户端列表和连接映射
3. 客户端注册、发现、建立连接
4. 支持 TCP、UDP、HTTP、WebSocket 协议穿透

---

## 二、系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              公网中继服务器                                  │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        信令 + 中继                                    │   │
│  │  ┌─────────────┐         ┌─────────────────────────────────────┐   │   │
│  │  │  客户端注册表  │         │           转发映射表                  │   │   │
│  │  │  - clientId  │         │  session_id │  client_a  │ client_b │   │   │
│  │  │  - services  │         │  abc123    │  socket    │  socket  │   │   │
│  │  │  - status   │         │  def456    │  socket    │  socket  │   │   │
│  │  └─────────────┘         └─────────────────────────────────────┘   │   │
│  │                                                                     │   │
│  │           控制通道(WebSocket)              数据通道(TCP/UDP)          │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
            ▲                                    ▲
            │ WebSocket (控制消息)               │ TCP/UDP (数据转发)
            │                                    │
    ┌───────┴────────┐                  ┌───────┴────────┐
    │   客户端A       │                  │   客户端B       │
    │  (NAT后)       │  ◄────所有流量经服务器────────►  (NAT后)        │
    │                │                  │                │
    │ ┌────────────┐ │                  │ ┌────────────┐ │
    │ │本地服务    │ │                  │ │本地服务    │ │
    │ │:8080      │ │                  │ │:3000      │ │
    │ └────────────┘ │                  │ └────────────┘ │
    └────────────────┘                  └────────────────┘
```

### 2.2 连接建立流程

```
┌──────────┐                      ┌──────────┐                      ┌──────────┐
│ 客户端A   │                      │  服务端   │                      │ 客户端B   │
└────┬─────┘                      └────┬─────┘                      └────┬─────┘
     │                                 │                                 │
     │  1. REGISTER {clientId, services}│                                 │
     ├─────────────────────────────────►│                                 │
     │                                 │  保存客户端信息                  │
     │                                 │                                 │
     │                                 │  2. REGISTER {clientId, services}│
     │                                 │◄────────────────────────────────┤
     │                                 │  保存客户端信息                  │
     │                                 │                                 │
     │  3. GET_CLIENT_LIST             │                                 │
     ├─────────────────────────────────►│                                 │
     │                                 │                                 │
     │  4. CLIENT_LIST [...]           │                                 │
     │◄────────────────────────────────┤                                 │
     │                                 │                                 │
     │  5. CONNECT_REQUEST             │                                 │
     │     {targetId, service}         │                                 │
     ├─────────────────────────────────►│  6. 转发连接请求                │
     │                                 ├────────────────────────────────►│
     │                                 │                                 │
     │  7. CREATE_SESSION              │  8. ACCEPT_SESSION               │
     │◄────────────────────────────────┤◄────────────────────────────────┤
     │     session_id=abc123           │     session_id=abc123           │
     │                                 │                                 │
     │  9. 连接中继数据通道             │  10. 连接中继数据通道            │
     ├─────────────────────────────────►│◄───────────────────────────────┤
     │     (TCP/UDP)                   │     (TCP/UDP)                   │
     │                                 │                                 │
     │  11. 数据转发 ←─────┐           │                 ┌─────── 数据转发│
     │     A ↔ Relay ↔ B ─┴───────────┴─────────────────┴───────────────►│
     │                                 │                                 │
```

---

## 三、详细设计

### 3.1 服务端设计

#### 3.1.1 模块结构

```
server/
├── index.ts              # 服务端入口
├── signaling.ts          # 信令服务器（WebSocket）
├── relay.ts              # 中继服务器（TCP/UDP）
├── client-manager.ts     # 客户端管理
├── session-manager.ts    # 会话管理
└── config.ts             # 配置
```

#### 3.1.2 数据结构

```typescript
// 客户端信息
interface Client {
  id: string;                    // 客户端唯一ID
  status: 'online' | 'offline';  // 在线状态
  registeredAt: number;          // 注册时间戳
  lastHeartbeat: number;         // 最后心跳时间
  services: Service[];           // 提供的服务列表
  controlSocket?: WebSocket;     // 控制通道连接
}

// 服务定义
interface Service {
  id: string;                    // 服务ID
  protocol: 'tcp' | 'udp' | 'http' | 'ws';
  localPort: number;             // 本地端口
  localHost: string;             // 本地地址
  description?: string;          // 描述
}

// 中继会话
interface RelaySession {
  id: string;                    // 会话ID
  clientA: string;               // 客户端A ID
  clientB: string;               // 客户端B ID
  service: Service;              // 目标服务
  status: 'connecting' | 'connected' | 'closed';
  createdAt: number;             // 创建时间
  socketA?: Socket;              // 客户端A数据通道
  socketB?: Socket;              // 客户端B数据通道
  bytesTransferred: number;      // 传输字节数
}
```

#### 3.1.3 信令协议（WebSocket消息）

```typescript
// 客户端 → 服务端
type ClientToServerMessage =
  | RegisterMessage
  | GetClientListMessage
  | ConnectRequestMessage
  | AcceptSessionMessage
  | RejectSessionMessage
  | HeartbeatMessage
  | UnregisterMessage;

// 服务端 → 客户端
type ServerToClientMessage =
  | RegisterResponseMessage
  | ClientListMessage
  | ConnectRequestMessage
  | CreateSessionMessage
  | SessionClosedMessage
  | ErrorMessage;

// 消息定义
interface RegisterMessage {
  type: 'register';
  payload: {
    clientId: string;
    services: Service[];
  };
}

interface RegisterResponseMessage {
  type: 'register_response';
  payload: {
    success: boolean;
    assignedId?: string;
    error?: string;
  };
}

interface GetClientListMessage {
  type: 'get_client_list';
}

interface ClientListMessage {
  type: 'client_list';
  payload: {
    clients: ClientInfo[];
  };
}

interface ClientInfo {
  id: string;
  status: 'online' | 'offline';
  services: Service[];
}

interface ConnectRequestMessage {
  type: 'connect_request';
  payload: {
    fromClientId: string;
    toClientId: string;
    serviceId: string;
    sessionId: string;
  };
}

interface CreateSessionMessage {
  type: 'create_session';
  payload: {
    sessionId: string;
    peerClientId: string;
    service: Service;
    relayAddr: {
      host: string;
      port: number;
      protocol: 'tcp' | 'udp';
    };
  };
}

interface AcceptSessionMessage {
  type: 'accept_session';
  payload: {
    sessionId: string;
  };
}

interface RejectSessionMessage {
  type: 'reject_session';
  payload: {
    sessionId: string;
    reason?: string;
  };
}

interface HeartbeatMessage {
  type: 'heartbeat';
  payload: {
    timestamp: number;
  };
}
```

#### 3.1.4 中继服务器

```typescript
class RelayServer {
  private sessions = new Map<string, RelaySession>();

  // TCP中继
  handleTCPConnection(socket: Socket, sessionId: string, clientId: string) {
    let session = this.sessions.get(sessionId);

    if (!session) {
      // 创建新会话
      session = {
        id: sessionId,
        clientA: clientId,
        clientB: null,
        socketA: socket,
        socketB: null,
        status: 'connecting',
        createdAt: Date.now(),
        bytesTransferred: 0
      };
      this.sessions.set(sessionId, session);
    } else {
      // 会话已存在，添加第二个客户端
      if (!session.clientB) {
        session.clientB = clientId;
        session.socketB = socket;
        session.status = 'connected';
        this.startForwarding(session);
      }
    }

    // 处理断开
    socket.on('close', () => {
      this.handleSessionClose(sessionId);
    });
  }

  // 开始双向转发
  private startForwarding(session: RelaySession) {
    const { socketA, socketB } = session;

    // A → B
    socketA?.on('data', (data) => {
      socketB?.write(data);
      session.bytesTransferred += data.length;
    });

    // B → A
    socketB?.on('data', (data) => {
      socketA?.write(data);
      session.bytesTransferred += data.length;
    });

    // 错误处理
    socketA?.on('error', (err) => this.handleError(session, err));
    socketB?.on('error', (err) => this.handleError(session, err));
  }

  // UDP中继
  private udpSockets = new Map<string, dgram.Socket>();

  handleUDPPacket(data: Buffer, rinfo: dgram.RemoteInfo, sessionId: string) {
    const session = this.sessions.get(sessionId);
    if (!session || session.status !== 'connected') return;

    // 转发给对方
    const targetSocket = this.getPeerUDPSocket(sessionId, rinfo);
    targetSocket?.send(data, session.peerPort, session.peerHost);
  }
}
```

### 3.2 客户端设计

#### 3.2.1 模块结构

```
client/
├── index.ts              # 客户端入口
├── signaling-client.ts   # 信令客户端
├── relay-client.ts       # 中继客户端
├── service-proxy.ts      # 服务代理（本地端口监听）
├── connection.ts         # 连接管理
└── config.ts             # 配置
```

#### 3.2.2 核心流程

```typescript
class TunnelClient {
  private signaling: SignalingClient;
  private relayClient: RelayClient;
  private services = new Map<string, ServiceProxy>();

  async start(config: ClientConfig) {
    // 1. 连接信令服务器
    await this.signaling.connect(config.serverUrl);

    // 2. 注册客户端
    await this.signaling.register({
      clientId: config.clientId,
      services: config.services
    });

    // 3. 启动心跳
    this.startHeartbeat();

    // 4. 监听连接请求
    this.signaling.on('connect_request', async (req) => {
      await this.handleIncomingConnection(req);
    });
  }

  // 发起连接（连接到其他客户端的服务）
  async connectTo(targetClientId: string, serviceId: string) {
    // 1. 请求连接
    const response = await this.signaling.requestConnect({
      toClientId: targetClientId,
      serviceId: serviceId
    });

    // 2. 收到会话创建通知
    const session = response.session;

    // 3. 连接中继服务器
    const relaySocket = await this.relayClient.connect(session.relayAddr);

    // 4. 创建本地代理
    const proxy = new ServiceProxy({
      localPort: session.localPort,
      relaySocket: relaySocket
    });

    await proxy.start();

    return proxy;
  }

  // 处理入站连接
  async handleIncomingConnection(request: ConnectRequest) {
    const { sessionId, peerClientId, service, relayAddr } = request;

    // 1. 查找请求的服务
    const targetService = this.findService(service.id);

    // 2. 连接本地服务
    const localSocket = await this.connectToLocalService(targetService);

    // 3. 连接中继服务器
    const relaySocket = await this.relayClient.connect(relayAddr);

    // 4. 接受会话
    await this.signaling.acceptSession({ sessionId });

    // 5. 开始转发
    this.startForwarding(localSocket, relaySocket);

    // 6. 通知对端连接已建立
    await this.signaling.notifyConnected({ sessionId });
  }
}
```

#### 3.2.3 服务代理（本地端口监听）

```typescript
class ServiceProxy {
  private server?: net.Server;
  private connections = new Set<net.Socket>();

  async start(config: ProxyConfig): Promise<void> {
    this.server = net.createServer((socket) => {
      this.handleClientConnection(socket);
    });

    this.server.listen(config.localPort, config.localHost);
  }

  private handleClientConnection(clientSocket: net.Socket) {
    // 连接到中继服务器
    const relaySocket = net.connect(this.relayAddr);

    // 双向转发
    clientSocket.on('data', (data) => {
      relaySocket.write(data);
    });

    relaySocket.on('data', (data) => {
      clientSocket.write(data);
    });

    // 清理
    clientSocket.on('close', () => {
      relaySocket.destroy();
      this.connections.delete(clientSocket);
    });

    relaySocket.on('close', () => {
      clientSocket.destroy();
    });

    this.connections.add(clientSocket);
  }
}
```

### 3.3 协议支持

#### 3.3.1 协议映射表

| 应用层协议 | 底层传输 | 中继方式 | 说明 |
|-----------|---------|---------|------|
| TCP | TCP | TCP中继 | 原样转发TCP流 |
| UDP | UDP | UDP中继 | 转发UDP数据报 |
| HTTP | TCP | TCP中继 | HTTP是TCP之上的应用，无需特殊处理 |
| WebSocket | TCP | TCP中继 | WS基于TCP，无需特殊处理 |

#### 3.3.2 中继数据通道

```typescript
// TCP中继：直接转发字节流
// 无需封装，直接使用原生TCP socket

// UDP中继：需要会话标识
interface UDPRelayPacket {
  sessionId: string;  // 4 bytes
  length: number;     // 2 bytes
  data: Buffer;       // variable
}

// UDP打洞不需要，纯中继直接转发
// 服务端根据 (remoteIP, remotePort) 识别会话
```

---

## 四、配置

### 4.1 服务端配置

```typescript
interface ServerConfig {
  // 服务器监听地址
  host: string;
  controlPort: number;    // 控制通道端口 (WebSocket)
  relayPort: number;      // 数据中继端口 (TCP/UDP)

  // 会话管理
  sessionTimeout: number;      // 会话超时时间 (ms)
  heartbeatInterval: number;   // 心跳间隔 (ms)
  heartbeatTimeout: number;    // 心跳超时 (ms)

  // 中继配置
  maxSessions: number;         // 最大并发会话数
  maxBytesPerSession: number;  // 单会话最大字节数
}
```

### 4.2 客户端配置

```typescript
interface ClientConfig {
  // 服务器连接
  serverUrl: string;           // ws://server:port

  // 客户端标识
  clientId: string;

  // 提供的服务列表
  services: Service[];

  // 连接配置
  autoReconnect: boolean;      // 自动重连
  reconnectInterval: number;   // 重连间隔 (ms)
}
```

---

## 五、实现计划

### 5.1 模块划分

| 模块 | 文件 | 代码量 | 优先级 |
|-----|------|-------|-------|
| 共享-协议定义 | `shared/protocol.ts` | ~150行 | P0 |
| 服务端-信令 | `server/signaling.ts` | ~200行 | P0 |
| 服务端-客户端管理 | `server/client-manager.ts` | ~100行 | P0 |
| 服务端-会话管理 | `server/session-manager.ts` | ~150行 | P0 |
| 服务端-中继 | `server/relay.ts` | ~200行 | P0 |
| 客户端-信令 | `client/signaling-client.ts` | ~150行 | P0 |
| 客户端-中继 | `client/relay-client.ts` | ~100行 | P0 |
| 客户端-服务代理 | `client/service-proxy.ts` | ~200行 | P0 |
| 客户端-主入口 | `client/index.ts` | ~100行 | P0 |
| CLI工具 | `cli/` | ~200行 | P1 |

**总计：约 1550 行代码**

### 5.2 开发顺序

**Phase 1: 基础框架 (2天)**
- [ ] 共享协议定义
- [ ] 服务端基础框架
- [ ] 客户端基础框架

**Phase 2: 信令系统 (2天)**
- [ ] WebSocket信令服务器
- [ ] 客户端注册/发现
- [ ] 心跳保活机制

**Phase 3: 中继系统 (2天)**
- [ ] TCP中继服务器
- [ ] UDP中继服务器
- [ ] 会话管理

**Phase 4: 客户端代理 (2天)**
- [ ] 本地服务代理
- [ ] 连接管理
- [ ] 数据转发

**Phase 5: 测试与优化 (2天)**
- [ ] 端到端测试
- [ ] 性能优化
- [ ] 错误处理

**预计完成时间：10天**

---

## 六、使用示例

### 6.1 启动服务端

```bash
# 安装
npm install

# 启动服务器
npm run server

# 输出
# [Server] Listening on 0.0.0.0:9000 (control)
# [Server] Relay listening on 0.0.0.0:9001 (tcp/udp)
```

### 6.2 启动客户端A（提供服务）

```bash
# 配置文件 client-a.json
{
  "serverUrl": "ws://server-ip:9000",
  "clientId": "client-a",
  "services": [
    {
      "id": "web-server",
      "protocol": "http",
      "localPort": 8080,
      "localHost": "localhost",
      "description": "本地Web服务"
    }
  ]
}

# 启动
npm run client -- --config client-a.json
```

### 6.3 启动客户端B（访问服务）

```bash
# 配置文件 client-b.json
{
  "serverUrl": "ws://server-ip:9000",
  "clientId": "client-b",
  "services": []
}

# 启动
npm run client -- --config client-b.json

# 连接到客户端A的服务
npm run client -- connect --target client-a --service web-server --local 3000

# 现在访问 localhost:3000 即可访问客户端A的 :8080 服务
```

---

## 七、优缺点分析

### 7.1 优点

| 优点 | 说明 |
|-----|------|
| 实现简单 | 无需处理NAT类型、打洞时序等复杂逻辑 |
| 稳定性高 | 100%连接成功率，不受NAT类型影响 |
| 开发快速 | 预计10天完成，对比P2P方案需3-4周 |
| 易于调试 | 所有流量经过服务器，便于抓包调试 |
| 支持所有协议 | TCP/UDP/HTTP/WS 都可以直接转发 |

### 7.2 缺点

| 缺点 | 说明 | 解决方案 |
|-----|------|---------|
| 服务器带宽成本 | 所有流量经过服务器 | 按需扩容，使用CDN |
| 延迟增加 | 数据多一跳 | 选择低延迟服务器 |
| 单点故障 | 服务器挂了全挂 | 部署多台服务器，负载均衡 |
| 隐私问题 | 服务器可见所有数据 | 后期可添加端到端加密 |

### 7.3 带宽估算

```
场景：10个用户，每个用户1MB/s吞吐

中继模式带宽 = 10用户 × 1MB/s × 2(双向) = 20MB/s
           = 160Mbps

云服务器成本估算（以阿里云为例）：
- 160Mbps 带宽约 1000-2000元/月
- 100个用户 × 1MB/s = 1.6Gbps ≈ 10000元/月

建议：
- 小规模使用（<10用户）：云服务器即可
- 中等规模（10-100用户）：考虑按量计费带宽
- 大规模（>100用户）：考虑P2P混合模式
```

---

## 八、未来扩展

### 8.1 从中继到P2P的迁移路径

```
第一阶段：纯中继（当前方案）
   └─ 快速上线，验证需求

第二阶段：添加NAT检测
   └─ 检测客户端NAT类型，收集数据

第三阶段：选择性P2P
   └─ 对简单NAT尝试P2P，失败回退中继

第四阶段：智能路由
   └─ 根据NAT类型、网络状况自动选择最优路径
```

### 8.2 可选增强功能

- [ ] 端到端加密（使用TLS）
- [ ] 客户端认证（Token）
- [ ] 数据压缩
- [ ] 多服务器负载均衡
- [ ] Web管理界面
- [ ] 流量统计和限速
- [ ] 断点续传（文件传输场景）
